В данной задаче вам предстоит реализовать библиотеку обхода файловой системы.

## Интерфейс

Публичный интерфейс библиотеки состоит из структуры `Walker`, у которой есть два интересных метода:
* `add_callback` - добавить функцию-коллбек, которая будет вызываться при обходе.
* `walk` - осуществить обход указанного пути.

Коллбек принимает единственный аргумент - `handle`. Он бывает 3 типов:
* `dir` - соответствует директории, которая встретилась при обходе. Если коллбек зовёт `.descend()`
на `dir`, то обход пойдёт вглубь этой директории.
* `file` - соответствует файлу, который встретился при обходе. Если коллбек зовёт `.read()` на `file`,
то содержимое этого файла будет прочитано и передано коллбеку в одном из следующих вызовов.
* `content` - соответствует содержимому файла.

В одном и том же `Walker` может быть множество коллбеков. Если какой-то коллбек не позвал `.descend()`
на директоррию, то он не должен вызываться на содержимое этой директории. При этом другие коллбеки
могли выразить желание обойти эту директорию, так что `Walker` всё равно должен в неё спуститься.

## Реализация

Реализуйте простой рекурсивный алгоритм обхода файловой системы:

1. Сделать list на текущий путь;
2. Для каждого entry текущего пути:
	* Если это файл:
		1. Позвать каждый коллбек на этот файл;
		2. Если нашёлся хотя бы один коллбек, заинтересованный в чтении этого файла - прочитать файл
   		и вызвать на его содержимое все заинтересованные коллбеки.
	* Если это директория:
		1. Позвать каждый коллбек на данную директорию;
		2. Если нашёлся хотя бы один коллбек, заинтересованный в обходе этой директории - вызваться
		рекурсивно на эту директорию со списком заинтересованных коллбеков.

Если в процессе обхода случится ошибка ввода/вывода, отбрасывайте ветвь, где произошла ошибка, но
не останавливайте обход. В качестве результата вызова `walk` верните любую из встретившихся ошибок,
либо `Ok(())`, если ошибок не было.

Порядок вызова коллбеков не специфицирован, он даже может меняться в процессе обхода.

## Советы

* При рекурсивных вызовах функции обхода удобно передавать заинтересованные коллбеки как
`&mut [Box<Callback>]`. Вызываясь рекурсивно для поддиректории, вы можете сделать partition
этого списка коллбеков по критерию заинтересованности, и вызваться для поддиректории с подслайсом
исходного слайса (`&mut callbacks[..index]`).
* Для партицирования в std есть функции [partition_in_place](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.partition_in_place) (unstable) и [partition](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.partition) - но они вам не подойдут, потому в них функция принимает константную ссылку на элемент (а вам нужна mut-ссылка на callback, чтобы позвать FnMut). Скорее всего, вам придётся реализовать свой partition с правильной сигнатурой.
