В данном проекте мы напишем библиотеку ORM ([Object-relational mapping](https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping)).

## Описание

В прикладных задачах часто возникает необходимость хранить данные во внешней базе. Зачастую
такие базы хранят данные в виде таблиц (так устроены все реляционные СУБД). Однако, в программном
коде работать с табличными данными неудобно, намного удобнее работать с нативными для языка
структурами или объектами. Задача ORM-библиотеки - дать прикладному коду возможность работать
с данными как с объектами, абстрагируясь от того, как именно данные будут разложены в таблице.

Продвинутые ORM-библиотеки поддерживают множество разных СУБД в качестве бекенда. В рамках данного
проекта мы ограничимся поддержкой лишь одной СУБД - SQLite3. Однако архитектура нашей библиотеки
будет поддерживать возможность добавления других бекендов.

### Примеры

Рассмотрим парочку примеров из тестов:

```rust
#[derive(Object)]
struct User {
    name: String,
    picture: Vec<u8>,
    visits: i64,
    balance: f64,
    is_admin: bool,
}
```

Структура User содержит в себе поля всех пяти типов, которые наша библиотека поддерживает.
`#[derive(Object)]` должен вывести для `User` трейт `Object`, принадлежащий нашей библиотеке.
Сам трейт, а также derive macro вы должны написать самостоятельно.

В нашей ORM работа с СУБД возможна только в рамках транзакций, которые создаются так:

```rust
// Создать соединение с СУБД.
let mut conn = Connection::open_sqlite_file("/path/to/file").unwrap();
// Создать транзакцию.
let tx = conn.new_transaction().unwrap();
```

Имея транзакцию, мы можем создать в ней объект:

```rust
// Создаём объект в памяти. Пока что этот объект не привязан ни к какой транзакции.
let user = User { /* ... */ };
// Теперь создадим этот объект в СУБД в рамках транзакции.
let tx_user = tx.create(user).unwrap();
```

Метод `create` возвращает значение типа `Tx<'a, User>`. Семантически это объект типа `User`, который
существует в рамках транзакции. Объект привязан к транзакции лайфтаймом `'a`, т.е. не может пережить
свою транзакцию.

У каждого существующего в рамках транзакции объекта есть идентификатор:

```rust
let user_id = tx_user.id();
```

В нашей ORM идентификаторы целочисленные.

Другой способ получить объект в рамках транзакции - это прочитать его из базы:

```rust
let tx_user = tx.get::<User>(user_id);
```

Чтобы читать или писать поля принадлежащего транзакции объекта, нужно использовать методы
`.borrow()` и `.borrow_mut()`:

```rust
println!("User name: {}", tx_user.borrow().name);
*tx_user.borrow_mut().visits += 1;
```

Можно заселектить один и тот же объект из базы дважды. Тогда объекты `Tx<...>`, которые транзакция
вернёт, будут ссылаться на один и тот же объект в памяти:

```rust
let tx_user = tx.get::<User>(user_id);
let tx_user_2 = tx.get::<User>(user_id);
*tx_user.borrow_mut().balance = 250;
assert_eq!(tx_user_2.borrow().balance, 250);
```

Если позвать `.borrow_mut()` на объект, уже имеющий активные borrows, произойдёт паника. Точно также
произойдёт паника, если позвать `.borrow()` на объект, имеющий активное mutable borrow.

Также, имея принадлежащий транзакции объект, можно его удалить:

```rust
tx_user.drop();
```

Если объект имеет активные borrows, произойдёт паника. Также к панике приведёт попытка позвать
`.borrow()` или `.borrow_mut()` на объект, который удалён (например, через `tx_user_2` в примере
выше).

Чтобы применить все изменения в рамках транзакции, необходимо завершить её вызовом `tx.commit()`.
Вызов `tx.rollback()`, наоборот, завершит транзакцию откатом всех изменений.

### Имена таблиц и колонок

По-умолчанию, таблица в СУБД называется одноимённо с типом объекта, а колонки - одноимённо с полями
объекта. Однако, имена таблиц и колонок можно менять атрибутами `table_name` и `column_name` на
структуре, например:

```rust
#[derive(Object)]
#[table_name("order_table")]
struct Order {
    #[column_name("IsTall")]
    is_tall: bool,
}
```

## Реализация

### Трейт Object

Трейт `Object` объявляется в `src/object.rs`. Вам нужно придумать, что этот трейт будет в себе
содержать.

Концептуально в нём должны быть:
* Схема: название типа объекта, название таблицы, список полей объекта (для каждого поля - его имя,
название колонки и тип).
* Способ представить объект в виде строчки в таблице.
* Способ создать экземпляр объекта из строчки в таблице.

Заметьте, что:
* Трейт `Object` почти наверняка не будет object safe (не сможет использоваться в виде `&dyn Object`).
Тем не менее, какие-то элементы из него вам захочется использовать в динамическом контексте. Для этого
объявите новый трейт и реализуйте его для всех объектов, реализующих `Object`, примерно так:

	```rust
	trait Store {
		// ...
	}

	impl<T: Object> Store for T {
		// ...
	}
	```

* Вам почти точно захочется делать downcasting из `&dyn Store` в конкретный тип объекта.
Именно поэтому `Object` объявлен как `trait Object: Any { /* ... */ }`.

### Работа с SQL

Вся работа с SQL инкапсулируется трейтом `StorageTransaction`, объявленным в `src/storage.rs`.
Задача `StorageTransaction` - предоставить нашей библиотеке интерфейс работы со стораджем,
абстрагированный от конкретной библиотеки.

Для работы с SQLite3 мы будем использовать библиотеку `rusqlite`.
Трейт `StorageTransaction` нужно реализовать для `rusqlite::Transaction`. Примеры работы с
rusqlite можно посмотреть в [документации](https://docs.rs/rusqlite).

Краткий справочник SQL-запросов, которые могут вам пригодиться:
* Проверить, существует ли таблица: `SELECT 1 FROM sqlite_master WHERE name = "table_name"`
* Создать таблицу (на примере объекта `User`, приведённого выше):

	```sql
	CREATE TABLE User(
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		name TEXT,
		picture BLOB,
		visits BIGINT,
		balance REAL,
		is_admin TINYINT, -- в SQLite3 нет булевского типа
	)
	```

* Вставить строку в таблицу: `INSERT INTO table(col1, col2) VALUES(123, 456)`
* Обновить значения в строке: `UPDATE table SET col1 = 123, col2 = 456 WHERE id = 789`
* Выбрать значения в строке: `SELECT co1, col2 FROM table WHERE id = 123`
* Удалить строку: `DELETE FROM table WHERE id = 123`

Заметьте, что методы `commit()` и `rollback()` у `rusqlite::Transaction` уничтожают объект транзакции,
однако эти же методы трейта `StorageTransaction` сохраняют его. Это обусловлено требованиями object safety:
если бы `.commit()` уничтожал объект транзакции, нельзя было бы использовать этот трейт как
`&dyn StorageTranasction`. Поэтому делайте коммит и откат напрямую через SQL командами `COMMIT`
и `ROLLBACK`.

### Транзакция и кеш объектов

Каждый объект, инстанциированный в рамках транзакции ORM (не путать с транзакцией rusqlite),
должен храниться в кеше объектов этой транзакции.
При коммите транзакции вы должны пройти по кешу объектов, проверить, какие объекты были изменены,
и применить эти изменения к нижележащей `StorageTransaction` (через метод `.update_row()`).
Те объекты, которые были удалены, необходимо удалить (`.remove_row()`).

Элегантный способ понять, что объект менялся - проверить, был ли хотя бы раз вызван `.borrow_mut()`.

Перед тем, как работать с таблицей конкретного типа объектов, вам сначала стоит убедиться,
что эта таблица существует. Если её нет - создайте её. Проверка таблицы происходит исключительно
по имени, проверять соответствие схемы таблицы ожидаемой схеме не предлагается.

### Обработка ошибок

Ошибки объявлены в `src/error.rs`. В рамках проекта мы выделили пять разновидностей ошибок:
* `NotFound` - запрошенный объект не найден.
* `UnexpectedType` - в одной из колонок получен не тот тип, который ожидался объектом.
* `MissingColumn` - какая-то из ожидаемых колонок отсутствует в таблице.
* `LockConflict` - база заблокирована конкурентной транзакцией (SQLite3 при работе с таблицей лочит
её целиком)
* `Storage` - любая другая ошибка нижележащего стораджа.

Мапинг из ошибок rusqlite в ошибки нашей библиотеки следующий:
* Ошибка `rusqlite::Error::QueryReturnedNoRows` - это `NotFound`.
* Ошибка `rusqlite::Error::InvalidColumnType` - это `UnexpectedType`.
* Ошибка `rusqlite::Error::SqliteFailure` c кодом `rusqlite::ErrorCode::DatabaseBusy` - это `LockConflict`.
* Ошибка `rusqlite::Error::SqliteFailire`, содержащая текст "no such column:" или "has no column named" -
это `MissingColumn` (кажется, другого способа нет).
* Всё остальное - это `StorageError`.

Заметьте, что большинство из этих ошибок содержат в себе контекст, которого нет в голом `rusqlite::Error`
(например, объект какого типа и с каким идентификатором мы не нашли). Возможно, вы захотите сделать
функцию, которая принимает ошибку `rusqlite` и дополнительный контекст, и создаёт из этого ошибку
нашей библиотеки.

## Советы и замечания

* Драйвер SQLite3 написан на С, так что вам нужно поставить его без помощи cargo. На Ubuntu
это делается так: `sudo apt install libsqlite3-dev`.
* Derive macro лучше реализовывать в самую последнюю очередь; сначала напишите реализации
трейта Object руками в `tests/tests.rs`.
* Начните с того, что заставьте заработать тест `test_create` (в нём использованы
методы `tx.create()`, `tx.get()` и `tx.commit()`).