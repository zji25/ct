chip8 - итрерпретируемый язык программирования, пользовавшийся популярностью для разработки игр и других приложений в конце 70х, 80е и 90е года.

В данном проекте мы предлагаем вам реализовать виртуальную машину, которая может запускать программы на chip8.

## 1. Описание chip8

Интерпретатор chip8 состоит из следующих компонент:

* 16 регистров размером в 8 бит (именуются `v0`, `v1`, ..., `vf`)
* 1 индексный регистр размером в 12 бит (именуется `I`)
* 4 килобайта памяти
* Стек вызовов, хранящий до 16 адресов возврата
* Счётчик команд, хранящий адрес следующей инструкции chip8 в памяти

Инструкции chip8 имеют константный размер в 16 бит. Всего в оригинальном chip8 34 инструкции. Примеры инструкций:

* `6xyy` - положить в регистр `vx` значение `yy`;
* `Axxx` - положить в регистр `I` значение `xxx`;
* `Fx55` - записать значения регистров `v0`..`vx` в память по адресам `I`..`I+x` и увеличить `I` на `x+1`;
* `Fx65` - прочитать значения из памяти по адресам `I`..`I+x` в регистры `v0`..`vx`;
* `1xxx` - установить счётчик команд равным `xxx` (jump);
* `2xxx` - положить адрес следующей инструкции на стек вызовов и установить счётчик команд равным `xxx` (call);
* `00EE` - осуществить возврат по стеку вызовов (return), т.е. извлечь верхний адрес со стека и установить счётчик инструкций равным этому адресу.

Также программы chip8 могут обращаться к компонентам платформы для осуществления ввода/вывода, работы со временем и генерации случайных чисел. Интерпретатор chip8 должен иметь следующие компоненты:

1. **Графический дисплей**. Chip8 поддерживает операцию рисования на дисплее размером 64x32 пикселей. Дисплей монохромный - т.е. каждый пиксель либо горит, либо не горит. Более подробно рисование будет описано далее.
2. **Клавиатура**. Chip8 поддерживает работу с 16-кнопочной клавиатурой.
3. **Таймер**. Есть инструкции, которые устанавливают и считывают текущее значение delay timer. Этот таймер уменьшается на единицу 60 раз в секунду. Также есть таймер звука - пока он больше 0, платформа должна издавать монотонный звук. Этот таймер также уменьшается на единицу 60 раз в секунду.

[Reference по инструкциям chip-8](https://chip8.gulrak.net/). В самом верху страницы оставьте галочку только напротив `CHIP-8`.

## 2. Архитектура приложения

Проект разбит на две части.

* Крейт `chip8` - библиотека, реализующая интерпретатор chip8 на произвольной платформе, если
эта платформа предоставляет необходимые API.
* Консольная утилита-раннер, лежащая в `chip8/tools/console-runner`.

Раннер полностью реализован за вас, вам нужно лишь дописать код в сам `chip8`.

Ниже дано описание разных компонент крейта `chip8`.

### 2.1. Interpreter

Центральным типом библиотеки является структура `Interpreter`.

Это generic-структура - она параметризуется типом, удовлетворяющим трейту `Platform`.

```rust
pub trait Platform {
    fn draw_sprite(&mut self, pos: Point, sprite: Sprite) -> bool;
    fn clear_screen(&mut self);
    fn get_delay_timer(&self) -> Word;
    fn set_delay_timer(&mut self, value: Word);
    fn set_sound_timer(&mut self, value: Word);
    fn is_key_down(&self, key: Key) -> bool;
    fn consume_key_press(&mut self) -> Option<Key>;
    fn get_random_word(&mut self) -> Word;
}
```

Таким образом, Platform инкапсулирует весь платформо-зависимый функционал.
В структуре Interpteter вам нужно реализовать только ядро языка chip8, а именно:

* Регистры
* Память
* Стек вызовов
* Интерпретацию opcodes

В конце файла `interpreter.rs` дано определение `enum Operation`, а также заготовка
реализации трейта `TryFrom<OpCode>` для `Operation`. `OpCode` - это обёртка над u16,
предоставляющая вам удобные методы для извлечения данных из опкода:

* `.read_address()` - извлекает младшие 12 бит из опкода
* `.read_word(i)` - извлекает i-й байт из опкода (i <= 1)
* `.read_nibble(i)` - извлекает i-й nibble из опкода (i <= 3). Nibble - это 4-битное значение.

Главный публичный метод `Interpreter` - это `run_next_instruction`: прочитать и исполнить
следующую операцию chip8.

### 2.2. ManagedInterpreter

`ManagedInterpreter` - это структура-обёртка над `Interpreter`, позволяющая явно управлять входами
`Interpteter`. В частности, `ManagedInterpreter`:

* Реализует дисплей как буфер в памяти. Пользователь `ManagedInterpreter` может в любой момент
прочитать содержимое этого буфера вызовом `.frame_buffer()`
* Реализует явное управление нажатиями клавиш. Пользователь `ManagedInterpteter` может в любой
момент задать, какие клавиши сейчас зажаты.
* Реализует управление временем. Каноничной частотой процессора chip8 считается 500 герц (500 операций в секунду).
`ManagedInterpreter` соответствующим образом продвигает таймеры при исполнении инструкций chip8.

Исполнение кода chip8 `ManagedInterpreter` реализует в двух методах:

* `.simulate_one_instruction` - исполнить одну инструкцию и соответствующим образом продвинуть таймеры;
* `.simulate_duration` - просимулировать прошествие конкретного промежутка времени -
т.е. исполнить соответствующее число инструкций и соответствующим образом продвинуть таймеры.

## 3. Реализация

Чтобы ваше решение было засчитано, оно должно проходить набор тестов. Каждый тест - это
программа на chip8, выход которой должен совпадать с выходом эталонной реализации. Набор тестов взят [отсюда](https://github.com/Timendus/chip8-test-suite).

Самый удобный способ реализовывать chip8, это двигаться последовательно от простых тестов к сложным, и реализовывать функциональность инкрементально.

### 3.1. Тест `chip8_logo`

Запускается командой `make run_chip8_logo`.

Если вы на Linux, то для запуска консольного раннера у вас должна быть установлена библиотека x11. На Ubuntu она ставится командой `sudo apt install libx11-dev`.

Чтобы этот тест прошёл, вам надо реализовать 5 инструкций:

* `00E0` - очистка экрана
* `6xnn` - загрузка значения `nn` в регистр `vx`
* `Annn` - загрузка значения `nnn` в регистр `I`
* `1nnn` - jump на адрес `nnn`
* `Dxyn` - отрисовка спрайта на экран

Спрайт - это битовая мастка, которую надо наложить XOR'ом на определённый регион дисплея.
Код `Dxyn` определяет спрайт как последовательность байт в памяти с адресами `I`..`I+n`.
Каждый байт означает горизонтальный ряд из 8 пикселей. Каждый ряд отрисовывается друг под другом - т.е. спрайт имеет размер `8 x n` пикселей. Регистры `vx` и `vy` задают верхний левый угол спрайта (в системе координат дисплея chip8 y-ось инвертирована - т.е. начало отсчёта в левом верхнем углу).

Инструкция `Dxyn` также проверяет, правда ли произошла коллизия - т.е. какой-то пиксель
дисплея при отрисовке был сброшен из 1 в 0. Если это произошло, то `vf` устанавливается равным `1`. Если нет, то `0`.

Заметьте, что в файле `platform.rs` уже реализована структура `Sprite`, являющаяся обёрткой над последовательностью байт. Более того, у неё уже есть метод `.iter_pixels`,
возвращающий итератор по ненулевым пикселям спрайта.

### 3.2. Тест `ibm logo`

Запускается командой `make run_ibm_logo`.

В дополнение к прошлым командам, вам нужно реализовать команду `7xnn` - прибавление `nn` к регистру `vx`.

### 3.3. Тест `corax`

Запускается командой `make run_corax`.

Этот тест проверяет более широкий набор команд ([см. описание в репозитории](https://github.com/Timendus/chip8-test-suite#corax-opcode-test)).

### 3.4. Тест `flags`

Запускается командой `make run_flags`.

Этот тест проверяет, что вы корректно работаете с флаговым регистром `vf` ([см. описание в репозитории](https://github.com/Timendus/chip8-test-suite#flags-test)).

### 3.5. Тест `quirks`

Запускается командой `make run_quirks`.

Этот тест проверяет разные граничные условия для вариаций платформы chip8 ([см. описание в репозитории](https://github.com/Timendus/chip8-test-suite#flags-test)).

Мы целимся в поддержку "ванильного" chip8, так что вам надо выбрать опцию 1.

Чтобы этот тест прошёл, вам нужно реализовать команды `Ex9E` и `ExA1` - они пропускают следующую инструкцию, если клавиша, номер которой равен `vx`, (не)зажата. Также вам придётся реализовать поддержку таймера.

### 3.6. Тест `keypad`

Запускается командой `make run_keypad`.

Для этого теста вам придётся реализовать команду `Fx0A` - она ожидает нажатия какой-либо клавиши и записывает её номер в `vx`.
Заметьте, что инструкция возвращает управление после того, как клавиша была **отпущена**.

За эту функциональность отвечает функция `Platform::consume_key_press()`.
Она возвращает последнюю нажатую клавишу. При этом, если после последнего
вызова этой функции не было нажато никакой клавишы, она возвращает `None`.
