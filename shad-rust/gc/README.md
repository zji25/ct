В данной задаче вам предлагается реализовать сборщик мусора для Rust.

## Интерфейс

API нашего упрощённого сборщика мусора будет состоять из двух типов:
* `Gc<T>` - умный указатель, ссылающийся на объект, которым владеет сборщик мусора.
  * Чтобы получить ссылку на `T`, пользователь зовёт `gc.borrow()`.
* `Arena` - создаёт новые `Gc<T>` и отслеживает их. В рамках задачи вы можете считать, что все `Gc<T>` создаются лишь одной ареной.
  * Когда пользователь хочет освободить все неиспользуемые объекты, он зовёт `arena.sweep()`.

Чтобы по типу `T` можно было понять, на какие другие объекты он ссылается, нужно, чтобы
для `T` был реализован трейт `Scan`. Содержимое трейта вам нужно придумать самостоятельно,
а также вам надо реализовать derive macro для `Scan`.

## Алгоритм сборки мусора

Пусть `Arena` содержит сильные указатели (`Rc`) на все выделенные в ней объекты, а
`Gc<T>` содержит слабый указатель (`Weak`). Тогда в наших объектах не может возникнуть
цикла из сильных указателей, и для того, чтобы удалить объект, арене достаточно удалить
сильную ссылку на него.

Заметьте, что `gc.borrow()` возвращает `GcRef<'a, T>`, котрый содержит в себе
"фантомную" ссылку на родительский `Gc<T>`. `GcRef`, конечно, содержит в себе
сильный указатель; но "фантомная" ссылка фиксирует инвариант, что для любого `GcRef`
всегда найдётся живой `Gc`. Мы будем использовать это свойство далее.

Алгоритм сборки мусора тогда может выглядеть так:
1. Запишем для каждого объекта кол-во других объектов, которые ссылаются на этот объект
(имеют на него `Gc<T>`).
2. Проверим для каждого объекта его счётчик слабых ссылок. Если значение счётчика больше,
чем записанное в п.1 для этого объекта число, это значит, что существует внешний `Gc<T>`,
который ссылается на этот объект. Запомним такие объекты.
3. Для каждого объекта из п.2 пометим все объекты, которые достижимы из этого объекта
(т.е. объекты, до которых можно добраться по внутренним `Gc<T>`).
4. Все объекты, не помеченные в п.3, являются недостижимыми для кода вне арены. Удалим
такие объекты.

Заметьте, что в п.4 все непомеченные объекты гарантированно имеют лишь один сильный
указатель - тот, которым владеет арена. Если это не так, то на объект имеется внешний
`GcRef`, но тогда по lifetime constraints на него имеется внешний `Gc`, а значит,
такой объект не мог попасть в кандидаты на удаление.

(Это рассуждение сломается, если пользователь решит сохранить `GcRef` внутри
garbage collected объекта. В текущей реализации от этого защищает ограничение
`T: 'static` у метода `Arena::alloc`. Другой способ добиться того же - сделать так,
чтобы наш derive macro отказался выводить Scan для типа, полем которого является `GcRef`.)

## Реализация

* Заметьте, что garbage collected объект может содержать внутри себя как "голые" `Gc` на
другие объекты, так и `Option<Gc<T>>`, `Vec<Gc<T>>`, `RefCell<Gc<T>>` и их произвольные
комбинации. Не надо генерировать специфичную логику для каждого типа внутри derive macro;
лучше напишите blanket implementations трейта Scan таким образом:

```rust
impl<T: Scan> Scan for Option<T> {
    // ...
}
```

* Прежде, чем писать derive macro, лучше реализуйте Scan для нужных типов прямо в файле
`tests/tests.rs`. Когда тесты пройдут, приступайте к написанию макроса в `gc-derive/src/lib.rs`.
* При обходе графа объектов удобнее всего работать с адресами этих объектов как с `usize`.
Чтобы получить адрес как `usize` из `Gc<T>`, делайте `self.weak.as_ptr() as usize`.
