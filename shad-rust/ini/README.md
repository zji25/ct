В данной задаче вам предстоит написать парсер ini-файлов. Пример файла в формате ini:

```ini
[section]
key = value
aba = caba

[other_section]
trololo = hohoho
```

## Спецификация

Ini - простой, но при этом не стандартизированный формат. В рамках задачи мы будем придерживаться следующей спецификации:

1. Каждая строка файла должна быть либо заголовком секции, либо парой ключ-значение,
либо пустой строкой.
1. Заголовок секции заключён в квадратные скобки. До или после квадратных скобок может
находиться произвольное кол-во пробельных символов. Заголовок секции может состоять
из любых символов, кроме квадратных скобок.
1. В паре ключ-значение ключ от значения отделяется знаком '='. До и после ключа и
значения может следовать произвольнок кол-во пробельных символов, они не считаются
частью ключа или значения. Если знак '=' в паре отсутствует, значение считается пустым.
1. Пустая строка - это строка, состоящая только из пробельных символов.
1. Пробельными символами считаются ' ', '\t', '\r'.
1. Первая пара ключ-значение обязана следовать после первой секции.
1. Ключи могут повторяться. Значением ключа считается то значение, которое появляется
в файле последним.
1. Секции могут повторяться. Повторяющиеся вхождения секции объединяются.

Можете посмотреть в `tests/tests.rs` примеры ожидаемого входа и выхода.

## Реализация

Реализуйте функцию `parse`, которая получает на вход содержимое ini-файла, а возвращает
`HashMap<String, HashMap<String, String>>`.

У `&str` есть много полезных методов. Возможно, вам пригодятся какие-то из следующих:

* [str::lines](https://doc.rust-lang.org/std/primitive.str.html#method.lines)
* [str::trim](https://doc.rust-lang.org/std/primitive.str.html#method.trim)
* [str::split](https://doc.rust-lang.org/std/primitive.str.html#method.split)
* [str::starts_with](https://doc.rust-lang.org/std/primitive.str.html#method.starts_with)
* [str::contains](https://doc.rust-lang.org/std/primitive.str.html#method.contains)

Старайтесь работать только со `&str`, т.к. это дешёвый тип, который ничего не аллоцирует,
а лишь ссылается на где-то лежащие данные. В идеале, вы должны позвать `.to_string()` лишь
в самый последний момент, когда осуществляете вставку в `HashMap`.

Если содержимое файла не соответствует спецификации - паникуйте.